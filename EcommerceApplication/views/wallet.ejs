<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <title>Wallet - Ecommerce</title>
    <style>
        body { background-color: #f8f9fa; }
        .wallet-container { max-width: 1000px; margin: 2rem auto; background: white; padding: 2rem; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .balance-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 10px; text-align: center; margin-bottom: 2rem; }
        .balance-card h2 { font-size: 3rem; margin: 0; }
        .redeem-card { background: #f8f9fa; padding: 1rem; border-radius: 5px; margin-bottom: 1rem; }
        .redeem-btn { background-color: #28a745; border: none; border-radius: 5px; }
        .redeem-btn:hover { background-color: #218838; }
        .history-table th, .history-table td { padding: 0.75rem; }
    </style>
    <link rel='stylesheet' href='/style.css'>
</head>
<body class="page-shell">
    <%- include('partials/topbar') %>
    <%- include('partials/navbar') %>
    <div class="container">
        <div class="wallet-container">
            <h1 class="mb-4">Loyalty Wallet</h1>

            <div class="balance-card">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h2 id="tokenBalanceDisplay"><%= tokenBalance %> Tokens</h2>
                        <p>Current Balance</p>
                    </div>
                    <button class="btn btn-light btn-sm" id="connectWalletBtn">Connect Wallet</button>
                </div>
                <div class="mt-2"><small id="walletAddressLabel">Wallet: not connected</small></div>
            </div>

            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-body">
                            <h5>Total Earned</h5>
                            <h3 class="text-success" data-total-earned data-value="<%= totalEarned %>"><%= totalEarned %></h3>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-body">
                            <h5>Total Redeemed</h5>
                            <h3 class="text-danger" id="totalRedeemedDisplay"><%= totalRedeemed %></h3>
                        </div>
                    </div>
                </div>
            </div>

            <h4>Redeem Options</h4>
            <div class="row">
                <% redeemOptions.forEach(option => { %>
                    <div class="col-md-4">
                        <div class="redeem-card">
                            <h5><%= option.name %></h5>
                            <p>Cost: <%= option.cost %> tokens</p>
                            <button class="btn redeem-btn" onclick="redeemTokens('<%= option.name %>', <%= option.cost %>)">Redeem</button>
                        </div>
                    </div>
                <% }); %>
            </div>

            <h4 class="mt-4">Transaction History</h4>
            <table class="table history-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Amount</th>
                        <th>Date</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <% transactionHistory.forEach(tx => { %>
                        <tr>
                            <td><%= tx.type %></td>
                            <td class="<%= tx.amount > 0 ? 'text-success' : 'text-danger' %>"><%= tx.amount %></td>
                            <td><%= tx.date %></td>
                            <td><%= tx.description || tx.orderId %></td>
                        </tr>
                    <% }); %>
                </tbody>
            </table>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>
    <script>
        (function() {
            const tokenAddress = "<%= loyaltyTokenAddress %>";
            const tokenOwner = "<%= loyaltyOwner %>";
            const decimals = Number("<%= loyaltyDecimals %>") || 18;
            const totalEarned = Number(document.querySelector('[data-total-earned]')?.dataset.value || 0);
            let totalRedeemed = Number("<%= totalRedeemed %>") || 0;

            const balanceEl = document.getElementById("tokenBalanceDisplay");
            const redeemedEl = document.getElementById("totalRedeemedDisplay");
            const connectBtn = document.getElementById("connectWalletBtn");
            const walletLabel = document.getElementById("walletAddressLabel");

            const ERC20_ABI = [
                "function balanceOf(address) view returns (uint256)",
                "function transfer(address to, uint256 amount) returns (bool)",
                "function decimals() view returns (uint8)"
            ];

            let currentAccount = null;

            const formatAddr = (addr) => addr ? `${addr.slice(0,6)}...${addr.slice(-4)}` : "not connected";

            async function ensureWallet() {
                if (!window.ethereum) throw new Error("MetaMask is required for token actions.");
                const accs = await window.ethereum.request({ method: "eth_requestAccounts" });
                currentAccount = accs[0];
                walletLabel.textContent = `Wallet: ${formatAddr(currentAccount)}`;
                return currentAccount;
            }

            async function getTokenContract(withSigner = false) {
                if (!tokenAddress) throw new Error("Loyalty token not deployed/configured.");
                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = withSigner ? await provider.getSigner() : null;
                return new ethers.Contract(tokenAddress, ERC20_ABI, withSigner ? signer : provider);
            }

            async function refreshBalance() {
                try {
                    if (!currentAccount) return;
                    const contract = await getTokenContract(false);
                    const raw = await contract.balanceOf(currentAccount);
                    const human = Number(ethers.formatUnits(raw, decimals));
                    balanceEl.textContent = `${human} Tokens`;
                    redeemedEl.textContent = totalRedeemed.toFixed(2).replace(/\\.00$/, '');
                } catch (err) {
                    console.warn("Failed to refresh token balance:", err.message || err);
                }
            }

            async function refreshRedeemed() {
                if (!currentAccount) return;
                try {
                    const res = await fetch(`/api/wallet/redeemed?wallet=${encodeURIComponent(currentAccount)}`);
                    const data = await res.json();
                    totalRedeemed = Number(data.totalRedeemed || 0);
                    redeemedEl.textContent = totalRedeemed.toFixed(2).replace(/\\.00$/, '');
                } catch (err) {
                    console.warn("Failed to load redeemed ledger:", err.message || err);
                }
            }

            async function redeemTokens(name, cost) {
                try {
                    await ensureWallet();
                    const contract = await getTokenContract(true);
                    const costUnits = ethers.parseUnits(String(cost), decimals);
                    const balance = await contract.balanceOf(currentAccount);
                    if (balance < costUnits) {
                        alert("Insufficient tokens!");
                        return;
                    }
                    const recipient = tokenOwner && tokenOwner !== "0x0000000000000000000000000000000000000000"
                        ? tokenOwner
                        : currentAccount;
                    const tx = await contract.transfer(recipient, costUnits);
                    await tx.wait();
                    await fetch("/api/wallet/redeemed", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ wallet: currentAccount, amount: cost, offerName: name })
                    });
                    await fetch("/api/wallet/claim-perk", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ wallet: currentAccount, offerName: name })
                    });
                    totalRedeemed += Number(cost);
                    alert(`Redeemed ${name} for ${cost} tokens!`);
                    await refreshRedeemed();
                    await refreshBalance();
                } catch (err) {
                    alert(err.message || "Redeem failed");
                }
            }

            window.redeemTokens = redeemTokens;
            connectBtn?.addEventListener("click", async () => {
                try { await ensureWallet(); await refreshRedeemed(); await refreshBalance(); } catch (err) { alert(err.message); }
            });

            if (window.ethereum) {
                window.ethereum.on("accountsChanged", () => { currentAccount = null; walletLabel.textContent = "Wallet: not connected"; });
            }

            // On load, try silent account detection (if user already authorized MetaMask)
            (async () => {
                if (!window.ethereum) return;
                try {
                    const accs = await window.ethereum.request({ method: "eth_accounts" });
                    if (accs && accs.length) {
                        currentAccount = accs[0];
                        walletLabel.textContent = `Wallet: ${formatAddr(currentAccount)}`;
                        await refreshRedeemed();
                        await refreshBalance();
                    }
                } catch (err) {
                    console.warn("Silent wallet check failed:", err.message || err);
                }
            })();
        })();
    </script>
</body>
</html>


